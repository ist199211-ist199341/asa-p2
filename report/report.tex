\documentclass[12pt,a4paper]{article}
\usepackage[legalpaper, portrait, margin=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{blindtext}
\usepackage{hyperref}

\graphicspath{ {./} }
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdftitle={Relatório ASA Projeto 2 2021/2022},
  pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupo \textbf{al007}}
\lhead{Relatório Projeto 2 ASA 2021/2022 LEIC-A}
\cfoot{Diogo Correia (99211) e Tomás Esteves (99341)}

\renewcommand{\footrulewidth}{0.2pt}

\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$\diamond$}

\begin{document}
  \section{Descrição do Problema e da Solução}

  Para resolver o \textbf{problema} utilizou-se uma lista de nós, um nó é composto pelo o número dos pais, o número de filhos e o número de vezes que foi visitado.\\
  Para verificar que o input dado é uma árvore geneológica é feito o seguinte:
  
  \begin{itemize}
    \setlength{\itemsep}{0pt}
      \item Ao ler o input verifica-se se um nó tem mais de 2 pais.
      \item Depois de ser lido o input todo, realiza-se uma DFS e no caso de se detetar que existe uma aresta que toca num nó já aberto mais ainda não fechado (GREY), sabe-se que existe um loop.
  \end{itemize}
  Se um dos requisitos for preenchido, o programa escreve "0" e termina.\\
  Depois do input ser tratado, são feitas 2 BFS, uma para cada um dos nós para os quais se quer detetar os ancestrais comuns mais próximos.
  Eliminam-se os nós que não pertencem a ambas as BFS.\\
  Explicar pq isto acontece\\
  E finalemente escreve-se por ordem crescente os nós restantes que não têm filhos.\\
 Se nenhum elemento for escrito, o programa escreve "-" e termina.

  \section{Análise Teórica}

  Seja $V$ o número de nós e $E$ o número de arestas.

  \begin{itemize}
    \setlength{\itemsep}{0pt}
    \item No problema começa-se por ler os vértices para os quais se quer detetar os ancestrais comuns mais próximos, assim como o número de nós e o número de arestas, feito em tempo constante, logo $\Theta(1)$:
    \begin{itemize}
      \setlength{\itemsep}{0pt}
      \item De seguida aloca-se dinamicamente memória para lista de nós e é inicializada. Logo, $\Theta(V)$ ou $\Theta(1)$.
      \item Acaba-se por depois tratar da informação relativa aos vértices. Logo, $O(E)$.
    \end{itemize}

   \item É efetuada uma DFS. Logo, $O(V + E)$.

  \item São efetuadas 2 BFS. Logo, $O(V + E)$.

  \item Remover nós que não são comuns a ambas as BFS. Logo, $O(V)$.

  \item Imprimir todos os nós que são ancestrais comuns mais próximos. Logo $\Theta(V)$.
  \end{itemize}
  Logo, no pior caso tem-se $O(V + E)$.\\
  O problema tem complexidade espacial $O(V)$, visto que se utilizou apenas uma lista de tamanho dos números de nós.

  \section{Avaliação Experimental dos Resultados}

  Foi criado instâncias de input com probablidade de criar aresta de 99\% (piot caso), para valores de nós entre 10 e 1000000, qnts por ordem de grandeza (?).\\
  O programa foi executado, pelo menos 100 (?) vezes para cada input, recorrendo ao programa \href{https://github.com/sharkdp/hyperfine}{\textit{hyperfine}}.
    
  \includegraphics[width=1\textwidth]{report.png}
  O gráfico apresentadotem uma escala $V + E$ no eixo dos $xx$ e o tempo em segundos no eixo dos $yy$.\\
  Os dados revelam uma reta (relativamente) linear, comprovando que a complexidade temporal do problema é, num caso geral, $O(V + E)$, tal como concluído na análise teórica.

\end{document}
