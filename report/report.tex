\documentclass[12pt,a4paper]{article}
\usepackage[legalpaper, portrait, margin=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{blindtext}
\usepackage{hyperref}

\graphicspath{ {./} }
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  filecolor=magenta,
  urlcolor=blue,
  citecolor=blue,
  pdftitle={Relatório ASA Projeto 2 2021/2022},
  pdfpagemode=FullScreen,
}

\pagestyle{fancy}
\fancyhf{}
\rhead{Grupo \textbf{al007}}
\lhead{Relatório Projeto 2 ASA 2021/2022 LEIC-A}
\cfoot{Diogo Correia (99211) e Tomás Esteves (99341)}

\renewcommand{\footrulewidth}{0.2pt}

\renewcommand{\labelitemii}{$\circ$}
\renewcommand{\labelitemiii}{$\diamond$}

\begin{document}
  \section{Descrição do Problema e da Solução}

  Para resolver o \textbf{problema} utilizou-se uma lista de nós, um nó é composto pelo o número dos pais, o número de filhos e o número de vezes que foi visitado.
  Para verificar que o input dado é uma árvore geneológica fazemos o seguinte:
  \begin{itemize}
    \setlength{\itemsep}{0pt}
      \item Ao ler o input se um nó tem mais de 2 pais.
      \item Depois de ser lido o input todo, realiza-se uma DFS e no caso de se detetar que existe uma aresta que toca num nó já aberto mais ainda não fechado (GREY), sabemos que existe um loop.
  \end{itemize}

  Se um destes requesitos é preenchido, o programa escreve "0" e termina.

  Depois do input ser tratado, são feitas 2 BFS, uma para cada um dos nós para os quais se quer detetar os ancestrais comuns mais próximos.

  Assim vamos apenas tratar dos nós que foram visitados 2 vezes, alcançáveis por ambas as BFS.
  
  Agora basta imprimir os nós que restam e que não têm filhos.

  Se não houver nenhum elemento que cumpre estes requesitos, o programa escreve "-".

  \section{Análise Teórica}

  Seja $V$ o número de nós e $E$ o número de arestas.

  No problema começamos por ler os vértices para os quais se quer detetar os ancestrais comuns mais próximos, assim como o número de nós e o número de arestas.
  De seguida alocamos dinamicamente memória para lista de nós e a inicializamos $O(V)$.
  Acabamos por depois adicionar a informação relativa aos vértices $O(E)$.

  É efetuada uma DFS $O(V + E)$.

  São efetuadas 2 BFS $O(V + E)$.

  Remover nós que não são comuns a ambas as BFS $O(V)$.

  Imprimir todos os nós que são ancestrais comuns mais próximos $O(V)$.
  
  Logo, no pior caso tem-se $O(V + E)$.

O problema tem complexidade espacial $O(V)$, visto que se utilizou apenas uma lista de tamanho dos números de nós.

  \section{Avaliação Experimental dos Resultados}

  O programa foi executado, pelo menos 5 vezes para cada sequência, para ambos os problemas, recorrendo ao programa \href{https://github.com/sharkdp/hyperfine}{\textit{hyperfine}}.

  \begin{wrapfigure}{r}{0.4\textwidth}
    \centering
    
  \end{wrapfigure}

  Para o problema 2, por ser o pior caso e para simplificar a análise, tomou-se sempre $N = M$, ou seja, o mesmo número de elementos para ambas as sequências.
  Foram sempre utilizados números comuns, visto que esse é o pior caso no problema 2.
  Foram utilizadas sequências de tamanho entre 10 e 100 000 elementos, 100 para cada ordem de grandeza.
  O gráfico apresentado à direta tem uma escala $NM$ no eixo dos $xx$.
  Os dados revelam uma reta linear, comprovando que a complexidade temporal do problema é, num caso geral, $O(NM)$, tal como concluído na análise teórica.



\end{document}
